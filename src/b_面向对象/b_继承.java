package b_面向对象;

public class b_继承 {
	// 继承的内存分布是嵌套的 查找方法的时候是从最外层的子类的开始查找直到找到为止
	// 1.java 只支持单继承 任何类都继承了object --重要的方法 equals 判断两个类是否相等使用tostring方法返回类的名字和hash值
	// 2.方法重写 重写的方法必须有形同的参数 名称 返回值类型 并且访问权限要保持不变或者进行升级
	// 3.方法重载 ，如果这个类里面有两个或者多个重名的方法，但是方法的（参数个数、类型、顺序）至少有一个不一样
	// 4.super 表示调用父类的方法 在构造函数中表示 super();表示调用父类的构造函数 super()不能在普通对象中使用方法
}
class Father {
	// java 访问控制符
	private int $pr = 12;// 自身可见
	int $ar = 12;// 自身同包可见
	protected int $br = 12;// 自身同包+子类可见
	public int $cr = 12;// 全可见
}
class Child extends Father {
	// java 多态 子类继承父类并且重写父类的方法 其他程序的参数传入父类类型 但是实际传递的是子类 参数调用的父类方法 也是子类重写后的
	Child child = null;
	public void j() {
		if (child instanceof Child) {// 运算符判断类属于哪个类 或者哪个类的子类
		}
	}
}
// final 关键字 可以修饰变量-常量 方法 不可重写但是可以重载(同名不同参数) 修饰类 不能被继承
// private类型的方法默认是final类型的。
/*
 * 使用final方法的原因有二： 第一、把方法锁定，防止任何继承类修改它的意义和实现。
 * 第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。
 */
final class heh {
	final int a = 0;
	final public void cc() {}
}
// static 关键字
/*
 * a、static方法就是没有this的方法，在static方法体中，!!不能调用非static方法，!!同 时也不能调用非静态成员变量
 * 反过来是可以的，即在非static方法体中，可以调用static方法。static方法，
 * 仅仅通过类名的方式调用。当然如果你用实例化的对象去调用static方法，也是 可以的，只是不推荐使用。
 * b、static变量也称之为静态变量，静态变量和非静态变量的区别是：静态变量被所有 对象所共享，而非静态变量当前对象所拥有，在创建对象的时候被初始化，存在
 * 多个副本，而static变量不存在多个副本。
 *  c、static代码块，如果一个类中有多个静态代码块!!!!!!，那么加载执行顺序为按次序执行
 * 4、jar包以及library：是对一系列功能的封装（打包）
 */
// this 关键字
/*
 * 1、this关键字的使用： a、成员变量和局部变量重名时，在方法体中调用成员变量，需要使用 this关键字。
 * b、把这个类自己的实例化对象当作参数进行传递时，可以使用this。
 *  c、内部类中，调用外部类的方法或变量 可使用：类名.this.（变量或方法名）
 * d、在同一个类中，可以使用this关键字调用同名的重载构造方法（前 提是：在构造方法中调用其他构造方法， 必须放在当前构造方法中第一行）。
 * 
 */
/*
 * super .super关键字 a、在父类已有的逻辑中加入自己的一些方法，可以使用super。需放在当前构造方法的首位。
 * b、当子类与父类有同名的成员变量或者同名的成员方法，那么子类中的元素大于父类中元素的优先级，所以需要使用super关键字调用父类中的方法或者成员变量
 * c、通过super后直接跟参数，可以调用父类的构造方法
 */